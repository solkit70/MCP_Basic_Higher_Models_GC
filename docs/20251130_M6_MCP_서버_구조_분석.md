# M6: MCP 서버 구조 분석 및 개발 가이드

**작성일**: 2025-11-30
**작성자**: Claude Code (Anthropic)
**목적**: 커스텀 MCP 서버 개발을 위한 개념 이해 및 실습 준비

---

## 1. MCP 서버란 무엇인가?

### 기본 개념

MCP 서버는 **"도구(Tools)를 제공하는 프로그램"**입니다.

```
[클라이언트 앱]  ←→  [MCP 서버]
    (요청)              (도구 실행)
    (응답 받음)         (결과 반환)
```

### 실제 예시

**echo.py 서버** (지난 시간에 사용):
- 제공 도구: `echo_tool` (입력 텍스트를 그대로 반환)
- 역할: 간단한 테스트용

**오늘 만들 file_server.py**:
- 제공 도구: `read_file`, `list_files`
- 역할: 파일 시스템 작업 수행

---

## 2. MCP 서버의 구조

### 핵심 컴포넌트

```python
from fastmcp import FastMCP

# 1. 서버 인스턴스 생성
mcp = FastMCP("서버 이름")

# 2. 도구 정의 (@mcp.tool() 데코레이터 사용)
@mcp.tool()
def my_tool(param1: str, param2: int) -> str:
    """도구 설명 (클라이언트에 표시됨)"""
    # 실제 작업 수행
    result = f"작업 완료: {param1}, {param2}"
    return result

# 3. 서버 실행 (stdio transport)
if __name__ == "__main__":
    mcp.run(transport="stdio")
```

### 각 부분의 역할

#### 1) FastMCP 인스턴스
```python
mcp = FastMCP("My Server", version="1.0.0")
```
- 서버의 이름과 버전 정의
- 클라이언트가 `initialize` 요청 시 이 정보 반환

#### 2) @mcp.tool() 데코레이터
```python
@mcp.tool()
def read_file(path: str) -> str:
    """파일 내용 읽기"""
    with open(path, 'r', encoding='utf-8') as f:
        return f.read()
```

**중요 포인트**:
- 함수 이름 = 도구 이름 (클라이언트가 이 이름으로 호출)
- 타입 힌트 필수 (`path: str`, `-> str`)
- docstring = 도구 설명 (클라이언트에게 표시)
- 반환값 = 도구 실행 결과

#### 3) 서버 실행
```python
mcp.run(transport="stdio")
```
- stdin/stdout으로 클라이언트와 통신
- JSON-RPC 2.0 프로토콜 자동 처리

---

## 3. 도구(Tool) 설계 원칙

### 좋은 도구의 특징

1. **단일 책임**: 하나의 도구는 하나의 작업만 수행
   - ✅ 좋음: `read_file(path)` - 파일 읽기만
   - ❌ 나쁨: `do_file_stuff(path, action)` - 여러 작업 혼합

2. **명확한 입력/출력**:
   ```python
   def read_file(path: str) -> str:  # 명확한 타입
       """파일 내용을 문자열로 반환"""
   ```

3. **에러 처리**:
   ```python
   @mcp.tool()
   def read_file(path: str) -> str:
       """파일 내용 읽기"""
       if not os.path.exists(path):
           raise FileNotFoundError(f"파일이 없습니다: {path}")

       try:
           with open(path, 'r', encoding='utf-8') as f:
               return f.read()
       except PermissionError:
           raise PermissionError(f"권한이 없습니다: {path}")
   ```

4. **보안 고려**:
   ```python
   from pathlib import Path

   def read_file(path: str) -> str:
       # 상대 경로 공격 방지
       safe_path = Path(path).resolve()
       base_dir = Path("./allowed_directory").resolve()

       if not safe_path.is_relative_to(base_dir):
           raise ValueError("허용되지 않은 경로입니다")
   ```

---

## 4. 도메인 선택 가이드

### 추천 도메인별 비교

| 도메인 | 난이도 | 실용성 | 확장성 | 추천도 |
|--------|--------|--------|--------|--------|
| **파일 시스템** | ⭐⭐☆☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 🔥🔥🔥 |
| 텍스트 처리 | ⭐☆☆☆☆ | ⭐⭐⭐☆☆ | ⭐⭐⭐☆☆ | 🔥🔥☆ |
| 계산기 | ⭐☆☆☆☆ | ⭐⭐☆☆☆ | ⭐⭐☆☆☆ | 🔥☆☆ |
| 데이터베이스 | ⭐⭐⭐⭐☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 🔥🔥☆ |
| 웹 스크래핑 | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐☆ | ⭐⭐⭐⭐☆ | 🔥🔥☆ |
| AI 모델 호출 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐☆☆ | 🔥☆☆ |

### 오늘의 선택: 파일 시스템 서버

**선택 이유**:

1. **배우기 쉬움**
   - Python의 기본 파일 I/O만 사용
   - 외부 라이브러리 불필요
   - 결과를 눈으로 바로 확인 가능

2. **실용성 높음**
   - 실제 앱에서 자주 사용하는 기능
   - 로그 파일 읽기, 설정 파일 관리 등에 활용
   - 다른 도구와 조합 가능 (파일 읽기 → 텍스트 처리)

3. **확장 가능**
   - 파일 쓰기 추가
   - 폴더 생성/삭제 추가
   - 파일 검색 기능 추가
   - 대용량 파일 스트리밍 처리

---

## 5. 오늘 구현할 도구 설계

### 도구 1: read_file

**목적**: 특정 경로의 파일 내용을 읽어서 반환

**입력**:
```python
path: str  # 파일 경로 (절대 또는 상대)
```

**출력**:
```python
-> str  # 파일 내용 (전체 텍스트)
```

**에러 케이스**:
- 파일이 없을 때 → `FileNotFoundError`
- 권한이 없을 때 → `PermissionError`
- 디렉토리를 지정했을 때 → `IsADirectoryError`
- 바이너리 파일일 때 → `UnicodeDecodeError`

**사용 예시**:
```json
{
  "name": "read_file",
  "arguments": {
    "path": "C:/temp/test.txt"
  }
}
```

---

### 도구 2: list_files

**목적**: 특정 폴더의 파일/디렉토리 목록 조회

**입력**:
```python
directory: str  # 폴더 경로
pattern: str = "*"  # 파일 패턴 (기본값: 모든 파일)
```

**출력**:
```python
-> list[dict]  # 파일 정보 목록
# [
#   {"name": "file1.txt", "type": "file", "size": 1024},
#   {"name": "folder1", "type": "directory", "size": 0}
# ]
```

**에러 케이스**:
- 폴더가 없을 때 → `NotADirectoryError`
- 권한이 없을 때 → `PermissionError`

**사용 예시**:
```json
{
  "name": "list_files",
  "arguments": {
    "directory": "C:/temp",
    "pattern": "*.txt"
  }
}
```

---

## 6. 개발 플로우

### Step 1: 서버 코드 작성
```
05-build-server/
├── file_server.py       # 메인 서버 코드
├── test_file_server.py  # 테스트 클라이언트
├── test_samples/        # 테스트용 샘플 파일
│   ├── sample1.txt
│   └── sample2.txt
└── README.md            # 사용 가이드
```

### Step 2: 독립 실행 테스트
```bash
# 서버 독립 실행
python file_server.py

# 테스트 클라이언트로 검증
python test_file_server.py
```

### Step 3: FastAPI 통합
```bash
# .env 파일 수정
MCP_EXEC_PATH=python C:\...\file_server.py

# FastAPI 재시작
uvicorn app.main:app --reload
```

### Step 4: HTTP 테스트
```bash
# 도구 목록 조회
GET http://localhost:8000/mcp/tools

# read_file 호출
POST http://localhost:8000/mcp/actions/read_file
{
  "path": "C:/temp/test.txt"
}

# list_files 호출
POST http://localhost:8000/mcp/actions/list_files
{
  "directory": "C:/temp"
}
```

---

## 7. 참고: FastMCP vs 순수 구현

### FastMCP 사용 (오늘 방법)

**장점**:
- 빠르고 간단
- 프로토콜 처리 자동
- 에러 처리 자동

**코드**:
```python
from fastmcp import FastMCP

mcp = FastMCP("File Server")

@mcp.tool()
def read_file(path: str) -> str:
    with open(path, 'r') as f:
        return f.read()

mcp.run(transport="stdio")
```

### 순수 구현 (고급)

**단점**:
- JSON-RPC 프로토콜 직접 구현 필요
- stdin/stdout 처리 직접 구현
- 에러 매핑 직접 구현

**코드**: 100줄 이상...

→ **FastMCP를 사용하는 것이 권장됩니다!**

---

## 8. 체크리스트

Phase 1 완료 후 확인:

- [ ] MCP 서버가 무엇인지 이해했나?
- [ ] @mcp.tool() 데코레이터의 역할을 아는가?
- [ ] 파일 서버가 왜 좋은 선택인지 이해했나?
- [ ] read_file과 list_files 도구가 무엇을 하는지 아는가?
- [ ] 개발 플로우(서버 작성 → 독립 테스트 → 통합)를 이해했나?

---

## 9. 다음 단계

Phase 1 완료! 이제 Phase 2로:

**Phase 2에서 할 일**:
1. `05-build-server/file_server.py` 작성 (완전한 코드)
2. 테스트용 샘플 파일 생성
3. 독립 테스트 클라이언트 작성
4. 서버 단독 실행 및 검증

→ **모든 코드는 AI가 작성합니다. 당신은 실행만 하면 됩니다!**

---

**Phase 1 완료 시간**: 약 5분 (문서 읽기)
**다음 Phase**: Phase 2 - 서버 구현
