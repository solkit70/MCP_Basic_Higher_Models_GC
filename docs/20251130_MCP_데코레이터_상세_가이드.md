# @mcp.tool() 데코레이터 완벽 가이드

**작성일**: 2025-11-30
**작성자**: Claude Code (Anthropic)
**목적**: MCP 서버 개발의 핵심인 @mcp.tool() 데코레이터의 역할과 동작 원리 이해

---

## 1. 기본 개념

`@mcp.tool()`은 **일반 Python 함수를 MCP 도구로 변환**하는 마법 같은 장치입니다.

### 데코레이터가 없을 때 vs 있을 때

```python
# 데코레이터 없음 - 그냥 일반 함수
def read_file(path: str) -> str:
    with open(path, 'r') as f:
        return f.read()

# 이 함수는 Python 내부에서만 사용 가능
# MCP 클라이언트는 이 함수를 "볼 수 없음"
```

```python
# 데코레이터 있음 - MCP 도구로 등록됨!
@mcp.tool()
def read_file(path: str) -> str:
    """파일 내용을 읽어서 반환합니다"""
    with open(path, 'r') as f:
        return f.read()

# 이제 이 함수는:
# 1. MCP 클라이언트가 "발견"할 수 있음
# 2. 원격으로 호출할 수 있음
# 3. 함수 정보(이름, 설명, 파라미터)가 자동으로 노출됨
```

---

## 2. 데코레이터가 하는 일 (자세히)

### 작업 1: 함수 정보 자동 추출

```python
@mcp.tool()
def read_file(path: str) -> str:
    """파일 내용을 읽어서 반환합니다"""
    with open(path, 'r') as f:
        return f.read()
```

데코레이터는 이 함수에서 다음 정보를 **자동으로 추출**합니다:

```json
{
  "name": "read_file",
  "description": "파일 내용을 읽어서 반환합니다",
  "inputSchema": {
    "type": "object",
    "properties": {
      "path": {
        "type": "string",
        "description": "파일 경로"
      }
    },
    "required": ["path"]
  }
}
```

**추출되는 정보**:
- ✅ **함수 이름** (`read_file`) → 도구 이름
- ✅ **docstring** (`"""파일 내용을..."""`) → 도구 설명
- ✅ **타입 힌트** (`path: str`) → 입력 스키마
- ✅ **반환 타입** (`-> str`) → 출력 타입

### 작업 2: 함수를 도구 레지스트리에 등록

```python
# FastMCP 내부에는 "도구 목록"이 있습니다
mcp._tools = []

# @mcp.tool()을 붙이면 자동으로 이 목록에 추가됨
@mcp.tool()
def read_file(path: str) -> str:
    ...

# 내부적으로 이렇게 됨:
# mcp._tools.append({
#     "name": "read_file",
#     "function": read_file,
#     "schema": {...}
# })
```

### 작업 3: MCP 프로토콜 요청 처리

클라이언트가 `tools/list` 요청을 보내면:

```python
# 클라이언트 요청:
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list"
}

# 데코레이터 덕분에 자동 응답:
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "read_file",
        "description": "파일 내용을 읽어서 반환합니다",
        "inputSchema": {...}
      }
    ]
  }
}
```

### 작업 4: 함수 호출 자동 매핑

클라이언트가 `tools/call` 요청을 보내면:

```python
# 클라이언트 요청:
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": {
      "path": "C:/temp/test.txt"
    }
  }
}

# 데코레이터가 자동으로:
# 1. "read_file"이라는 이름의 도구를 찾음
# 2. arguments를 함수 파라미터로 변환
# 3. 함수 호출: read_file(path="C:/temp/test.txt")
# 4. 결과를 JSON-RPC 응답으로 변환
# 5. 응답 전송

{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "파일 내용이 여기에..."
      }
    ]
  }
}
```

---

## 3. 실제 비유: 식당 메뉴판

### 데코레이터 없음

```python
# 주방에만 있는 레시피
def make_pasta(sauce: str) -> str:
    return f"파스타 with {sauce}"

# 손님(클라이언트)은 이 레시피를 모름
# 직접 주방에 들어가야만 만들 수 있음
```

### 데코레이터 있음

```python
# 메뉴판에 등록된 요리
@mcp.tool()
def make_pasta(sauce: str) -> str:
    """맛있는 파스타를 만듭니다"""
    return f"파스타 with {sauce}"

# 이제:
# 1. 메뉴판에 "파스타" 항목이 생김
# 2. 손님이 "파스타 주세요" 하면
# 3. 웨이터(MCP 프로토콜)가 주방에 전달
# 4. 요리가 나옴
```

**데코레이터 = 메뉴판에 등록하는 행위**

---

## 4. 코드 비교: 데코레이터의 위력

### 데코레이터 없이 MCP 서버 만들기 (100줄+)

```python
# 복잡하고 어려움
import json
import sys

def read_file(path):
    with open(path, 'r') as f:
        return f.read()

# JSON-RPC 프로토콜 직접 구현
while True:
    line = sys.stdin.readline()
    if not line:
        break

    request = json.loads(line)

    if request["method"] == "tools/list":
        response = {
            "jsonrpc": "2.0",
            "id": request["id"],
            "result": {
                "tools": [
                    {
                        "name": "read_file",
                        "description": "...",
                        "inputSchema": {...}
                    }
                ]
            }
        }
        print(json.dumps(response))

    elif request["method"] == "tools/call":
        tool_name = request["params"]["name"]
        if tool_name == "read_file":
            path = request["params"]["arguments"]["path"]
            result = read_file(path)
            response = {...}
            print(json.dumps(response))

    # ... 에러 처리, 타임아웃, 등등...
```

### 데코레이터 사용 (5줄!)

```python
# 간단하고 명확함
from fastmcp import FastMCP

mcp = FastMCP("File Server")

@mcp.tool()
def read_file(path: str) -> str:
    """파일 내용을 읽어서 반환합니다"""
    with open(path, 'r') as f:
        return f.read()

mcp.run(transport="stdio")
```

→ **데코레이터가 100줄의 복잡한 코드를 숨겨줍니다!**

---

## 5. 왜 타입 힌트가 중요한가?

### 나쁜 예: 타입 힌트 없음

```python
@mcp.tool()
def read_file(path):  # 타입을 모름!
    with open(path, 'r') as f:
        return f.read()

# 클라이언트가 받는 정보:
{
  "name": "read_file",
  "inputSchema": {}  # 비어있음!
}
```

**문제점**:
- 클라이언트가 어떤 타입의 값을 보내야 하는지 모름
- 자동 검증 불가능
- 문서화 안 됨

### 좋은 예: 타입 힌트 있음

```python
@mcp.tool()
def read_file(path: str) -> str:  # 타입 명확!
    """파일 내용을 읽어서 반환합니다"""
    with open(path, 'r') as f:
        return f.read()

# 클라이언트가 받는 정보:
{
  "name": "read_file",
  "description": "파일 내용을 읽어서 반환합니다",
  "inputSchema": {
    "properties": {
      "path": {"type": "string"}
    },
    "required": ["path"]
  }
}
```

**장점**:
- ✅ 클라이언트가 "어떻게 사용하는지" 정확히 알 수 있음
- ✅ 자동 타입 검증
- ✅ 자동 문서화
- ✅ IDE 자동완성 지원

---

## 6. 복잡한 타입 예시

### 기본 타입

```python
@mcp.tool()
def basic_types(
    text: str,           # 문자열
    number: int,         # 정수
    decimal: float,      # 소수
    flag: bool           # 참/거짓
) -> str:
    """기본 타입 예시"""
    return f"처리 완료"
```

### 리스트와 딕셔너리

```python
from typing import List, Dict

@mcp.tool()
def complex_types(
    items: List[str],              # 문자열 리스트
    config: Dict[str, int],        # 문자열→정수 딕셔너리
    optional: str = "default"      # 선택적 파라미터 (기본값)
) -> List[Dict[str, str]]:
    """복잡한 타입 예시"""
    return [{"result": item} for item in items]
```

### Pydantic 모델 (권장)

```python
from pydantic import BaseModel

class FileInfo(BaseModel):
    path: str
    encoding: str = "utf-8"
    max_size: int = 1024000

@mcp.tool()
def read_file_advanced(info: FileInfo) -> str:
    """Pydantic 모델 사용 예시"""
    with open(info.path, 'r', encoding=info.encoding) as f:
        content = f.read(info.max_size)
    return content
```

**Pydantic 장점**:
- 더 명확한 스키마
- 자동 검증 강화
- 기본값 지원
- 중첩된 구조 표현 가능

---

## 7. 에러 처리와 데코레이터

### 에러는 자동으로 처리됨

```python
@mcp.tool()
def read_file(path: str) -> str:
    """파일 내용 읽기"""
    # 에러를 그냥 raise 하면 됨
    if not os.path.exists(path):
        raise FileNotFoundError(f"파일이 없습니다: {path}")

    with open(path, 'r') as f:
        return f.read()

# 클라이언트 요청 시:
# → 파일이 없으면 자동으로 JSON-RPC 에러 응답
{
  "jsonrpc": "2.0",
  "id": 2,
  "error": {
    "code": -32000,
    "message": "파일이 없습니다: C:/temp/missing.txt"
  }
}
```

### 커스텀 에러 메시지

```python
@mcp.tool()
def safe_read_file(path: str) -> str:
    """안전한 파일 읽기"""
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        raise ValueError(f"파일을 찾을 수 없습니다: {path}")
    except PermissionError:
        raise ValueError(f"파일 접근 권한이 없습니다: {path}")
    except UnicodeDecodeError:
        raise ValueError(f"텍스트 파일이 아닙니다: {path}")
```

---

## 8. 데코레이터 동작 흐름도

```
[1] 서버 시작
    ↓
[2] @mcp.tool() 데코레이터가 함수들을 스캔
    ↓
[3] 각 함수의 메타데이터 추출
    - 이름
    - docstring
    - 타입 힌트
    ↓
[4] 도구 레지스트리에 등록
    mcp._tools = [tool1, tool2, ...]
    ↓
[5] 클라이언트 연결 대기
    ↓
[6] 클라이언트 요청 수신
    ↓
[7-A] tools/list 요청?
      → 레지스트리 정보 반환
    ↓
[7-B] tools/call 요청?
      → 도구 이름으로 함수 검색
      → arguments를 파라미터로 변환
      → 함수 실행
      → 결과를 JSON-RPC 응답으로 변환
      → 클라이언트에 전송
```

---

## 9. 핵심 정리

### @mcp.tool()이 하는 일

1. ✅ **함수를 "발견 가능"하게 만듦**
   - 클라이언트가 `tools/list`로 도구 목록 조회 가능

2. ✅ **함수 정보를 자동으로 추출**
   - 이름, 설명(docstring), 파라미터(타입 힌트) → JSON 스키마

3. ✅ **원격 호출을 가능하게 함**
   - 클라이언트의 `tools/call` 요청 → 함수 실행 → 결과 반환

4. ✅ **복잡한 프로토콜 처리를 자동화**
   - JSON-RPC 2.0 요청/응답 변환
   - 에러 처리
   - 타입 검증

### 데코레이터의 마법

```python
@mcp.tool()  # <- 이 한 줄이
def my_function():
    pass

# 일반 함수를 → 네트워크를 통해 호출 가능한 도구로 변환!
```

---

## 10. 실전 체크리스트

MCP 도구를 만들 때 확인할 것:

- [ ] `@mcp.tool()` 데코레이터를 붙였는가?
- [ ] 모든 파라미터에 타입 힌트가 있는가? (`param: str`)
- [ ] 반환 타입 힌트가 있는가? (`-> str`)
- [ ] docstring이 있는가? (`"""설명"""`)
- [ ] 에러 케이스를 처리했는가? (`raise` 또는 `try-except`)
- [ ] 함수 이름이 명확한가? (`read_file`, `list_files`)
- [ ] 하나의 함수가 하나의 작업만 하는가? (단일 책임)

---

## 11. 다음 단계

이제 `@mcp.tool()` 데코레이터를 이해했으니:

1. **Phase 2**에서 실제로 사용해보기
2. `read_file`, `list_files` 도구 구현
3. 독립 실행 및 테스트
4. FastAPI 앱과 통합

---

**작성 완료**: 2025-11-30
**다음**: Phase 2 - 파일 서버 구현
